// Time Complexity: O(m * n) : where m is the number of rows and n is the number of columns
// Space Complexity: O(1)

// Algorithm
/**
 1) Execute on top row.
 2) As soon as top row finishes, increase top by 1.
 3) Execute on right column from top to bottom, then decrease right by 1.
 4) Execute on bottom row from right to left, then decrease bottom by 1.
 5) Execute on left column from bottom to top, then increase left by 1.

 Be sure to check for breached bounds in points 4 and 5.
 **/


class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> result = new ArrayList<>();

        if(matrix == null || matrix.length == 0){
            return result;
        }

        int m = matrix.length ;
        int n = matrix[0].length;

        int top = 0, left = 0;
        int right = n - 1;
        int bottom = m - 1;

        while(top <= bottom && left <= right){

            //top row
            for(int i = left ; i <= right ; i++){

                result.add(matrix[top][i]);

            }
            top++;

            // right col
            for(int i = top ; i <= bottom ; i++){

                result.add(matrix[i][right]);

            }
            right--;

            //condition is there to check if the bounds have been breached or not.
            if(top <= bottom){  // we can also check both conditions if confusion arises
                // bottom row
                for(int i = right ; i >= left ; i--){

                    result.add(matrix[bottom][i]);

                }
            }
            bottom--;


            // left col, condition is there to check if the bounds have been breached or not.
            if(left <= right){ // we can also check both conditions if confusion arises
                for(int i = bottom ; i >= top ; i--){

                    result.add(matrix[i][left]);

                }
            }
            left++;

        }
        return result;

    }
}
