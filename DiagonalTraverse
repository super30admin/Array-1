// Time complexity: O(m*n) : m-> number of rows and n-> number of columns
// Space complexity: O(1) : As no extra computational space is used, we create an array that needs to be returned

// Algorithm:

/**
 *  1) Solve this direction wise, direction 1 means up, -1 means down.
 *  2) Take initial direction as 1.
 *  3) For the case where direction is upwards, we have 3 cases:
 *      i) Whether we are on the last column, here change direction and increase row count.
 *      ii) We are on the first row, change direction and increase row by 1.
 *      iii) Else: decrease row and increase column index.
 *  4) Reverse the case for downward direction.
 */


class Solution {
    public int[] findDiagonalOrder(int[][] matrix) {

        if(matrix == null || matrix.length == 0) return new int[0];

        int m = matrix.length;
        int n = matrix[0].length;

        int[] result = new int[m*n];

        int i = 0, r = 0 , c = 0, dir = 1;

        while(i < m*n){

            result[i] = matrix[r][c];

            if(dir == 1){
                // take this case first to prevent out of bounds exception for r == 0, c might go out of bounds
                if(c == n - 1){
                    dir = -1;
                    r++;
                } else if(r == 0){
                    dir = -1;
                    c++;
                } else{
                    r--;
                    c++;
                }
            }
            else{
                // take this case first to prevent out of bounds exception for c == 0, r might go out of bounds
                if(r == m - 1){
                    dir = 1;
                    c++;
                } else if(c == 0){
                    dir = 1;
                    r++;
                } else{
                    c--;
                    r++;
                }
            }

            i++;

        }
        return result;



    }
}
